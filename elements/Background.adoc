/**
 * Background element class.<br/>
 * Background can be a part of another complex element (chart, legend, title and so on),
 * or used separately.<br/>
 * Background has a fill, a border and corner shape settings.<br/>
 * <b>Note:</b> Always specify display bounds if you use Background separately.
 * @example <t>simple-h100</t>
 * new anychart.elements.Background()
 *   .bounds( new anychart.math.Rect(10, 10, stage.width()-20, stage.height() - 20) )
 *   .container(stage).draw();
 * @param {anychart.elements.Background.CornerType=} opt_cornerType [anychart.elements.Background.CornerType.ROUND] Type
 *  of the background corners.
 * @param {...(number|string)} var_args Radii set, much like {@link anychart.elements.Background#corners} but
 *  without an array.
 * @extends {anychart.VisualBaseWithBounds}
 * @constructor
 */
anychart.elements.Background;

/**
 * Types of the corner.
 * @enum {string}
 */
anychart.elements.Background.CornerType;

/**
   * @illustration
   * stage.width(200).height(30);
   * stage.text(35, 10, 'Square corners').fontSize(12);
   * stage.path()
   *   .moveTo(5, 25)
   *   .lineTo(5, 10)
   *   .lineTo(20, 10)
   *   .stroke('3 #F00')
   * stage.path()
   *   .moveTo(5,30)
   *   .lineTo(5,25)
   *   .moveTo(20, 10)
   *   .lineTo(25, 10)
   *   .stroke('3 #666')
   */
anychart.elements.Background.CornerType.NONE;

/**
   * @illustration
   * stage.width(200).height(30);
   * stage.text(35, 10, 'Round corners')
   * stage.path()
   *   .moveTo(5, 25)
   *   .arcToByEndPoint(20, 10, 15, 15, false, true)
   *   .stroke('3 #F00')
   *  stage.path()
   *   .moveTo(5,30)
   *   .lineTo(5,25)
   *   .moveTo(20, 10)
   *   .lineTo(25, 10)
   *   .stroke('3 #666')
   */
anychart.elements.Background.CornerType.ROUND;

/**
   * @illustration
   * stage.width(200).height(30);
   * stage.text(35, 10, 'Cut corners')
   * stage.path()
   *   .moveTo(5, 25)
   *   .lineTo(20, 10)
   *   .stroke('3 #F00')
   *  stage.path()
   *   .moveTo(5,30)
   *   .lineTo(5,25)
   *   .moveTo(20, 10)
   *   .lineTo(25, 10)
   *   .stroke('3 #666')
   */
anychart.elements.Background.CornerType.CUT;

/**
   * @illustration
   * stage.width(200).height(30);
   * stage.text(35, 10, 'Round-inner corners')
   * stage.path()
   *   .moveTo(5, 25)
   *   .arcToByEndPoint(20, 10, 15, 15, false, false)
   *   .stroke('3 #F00')
   *  stage.path()
   *   .moveTo(5,30)
   *   .lineTo(5,25)
   *   .moveTo(20, 10)
   *   .lineTo(25, 10)
   *   .stroke('3 #666')
   */
anychart.elements.Background.CornerType.ROUND_INNER;

/**
 * Getter for current corner radius.
 * @return {(number|string|Array.<number>)} Current corner settings.
 */
anychart.elements.Background.prototype.corners;

/** topLeft, topRight, bottomRight, bottomLeft
 * Setter for corner's radius by one value.
 * @example <c>One for all.</c><t>simple-h100</t>
 * new anychart.elements.Background()
 *   .cornerType(anychart.elements.Background.CornerType.CUT)
 *   .corners(10) // same .corners('10px')
 *   .bounds( new anychart.math.Rect(10, 10, stage.width()-20, stage.height() - 20) )
 *   .stroke('#000 2').fill('none').container(stage).draw();
 * @example <c>One for all.</c><t>simple-h100</t>
 * new anychart.elements.Background()
 *   .cornerType(anychart.elements.Background.CornerType.CUT)
 *   .corners([5, 7, 12, 7])
 *    // same .corners('5 7 12 7')
 *    // same .corners('5px 7px 12px 7px')
 *   .bounds( new anychart.math.Rect(10, 10, stage.width()-20, stage.height() - 20) )
 *   .stroke('#000 2').fill('none').container(stage).draw();
 * @param {(number|string|Array.<number>)=} opt_value ['0px'] Value to set.<br/><b>Note:</b> If array has less than 4 elements
 *  (or string provide less than 4 values), the first value is set for all four corners.
 * @return {!anychart.elements.Background} {@link anychart.elements.Background} instance for method chaining.
 */
anychart.elements.Background.prototype.corners;

/**
 * Setter for corner radius by each value.
 * @example <t>simple-h100</t>
 * new anychart.elements.Background()
 *   .cornerType(anychart.elements.Background.CornerType.CUT)
 *   .corners(15, 7, 12, 7)
 *   .bounds( new anychart.math.Rect(10, 10, stage.width()-20, stage.height() - 20) )
 *   .stroke('#000 2').fill('none').container(stage).draw();
 * @param {(number|string)=} opt_topLeft Top left corner value.
 * @param {(number|string)=} opt_topRight Top right corner value.
 * @param {(number|string)=} opt_bottomRight Bottom left corner value.
 * @param {(number|string)=} opt_bottomLeft Bottom right corner value.
 * @return {!anychart.elements.Background} {@link anychart.elements.Background} instance for method chaining.
 */
anychart.elements.Background.prototype.corners;

/**
 * Getter for current corner type.
 * @return {anychart.elements.Background.CornerType} Corners type.
 */
anychart.elements.Background.prototype.cornerType;

/**
 * Setter for corner type.
 * @example <t>simple-h100</t>
 * new anychart.elements.Background()
 *   .cornerType(anychart.elements.Background.CornerType.ROUND_INNER)
 *   .corners(10)
 *   .stroke('#000 2')
 *   .bounds( new anychart.math.Rect(10, 10, stage.width()-20, stage.height() - 20) )
 *   .fill('none').container(stage).draw();
 * @param {anychart.elements.Background.CornerType=} opt_value [{@link anychart.elements.Background.CornerType}.ROUND] Value to set.
 * @return {!anychart.elements.Background} {@link anychart.elements.Background} instance for method chaining.
 */
anychart.elements.Background.prototype.cornerType;

/**
 * Returns current fill.
 * @return {!anychart.graphics.vector.Fill} Current fill settings (empty fill is always 'none').
 */
anychart.elements.Background.prototype.fill;

/**
 * Sets fill settings using an object or a string.<br/>
 * Accepts:
 * <ul>
 * <li>{@link anychart.graphics.vector.LinearGradientFill}</li>
 * <li>{@link anychart.graphics.vector.RadialGradientFill}</li>
 * <li>{@link anychart.graphics.vector.Fill}</li>
 * <li>{@link anychart.graphics.vector.ImageFill}</li>
 * </ul>
 * or a color as a string, along with opacity, if needed, format is '<b>Color Opacity</b>',
 * e.g. 'red .5'.
 * @shortDescription Sets fill settings using an object or a string.
 * @example <c>Solid Fill</c><t>simple-h100</t>
 * var bg = new anychart.elements.Background();
 * // Set fill
 *   bg.fill('red 0.1');
 * // the same
 * // bg.fill('#ff0000 0.1');
 * // or
 * // bg.fill({color: 'red', opacity: 0.1});
 * // or
 * // bg.fill('#ff0000 0.1');
 * // then draw
 * bg.container(stage)
 *   .bounds( new anychart.math.Rect(10, 10, stage.width()-20, stage.height()-20) )
 *   .draw();
 * @example <c>Gradient Fill</c><t>simple-h100</t>
 * var bg = new anychart.elements.Background();
 * // Set fill
 *   bg.fill({keys:['red .1', 'orange'], mode: true, angle: 45});
 * bg.container(stage)
 *   .bounds( new anychart.math.Rect(10, 10, stage.width()-20, stage.height()-20) )
 *   .draw();
 * @example <c>Image Fill</c><t>simple-h100</t>
 * new anychart.elements.Background()
 *    .bounds( new anychart.math.Rect(10, 10, stage.width()-20, stage.height() - 20) )
 *    .stroke('#000 2').fill({
 *        src: 'https://static.anychart.com/rainbow.png',
 *        mode: anychart.graphics.vector.ImageFillMode.TILE
 *     }).container(stage).draw();
 * @param {anychart.graphics.vector.Fill} value ['#000 0.5'] Fill as an object or a string.
 * @return {!anychart.graphics.vector.Shape} {@link anychart.graphics.vector.Shape} instance for method chaining.
 * */
anychart.elements.Background.prototype.fill;

/**
 * Fill as a color with opacity.<br/>
 * <b>Note:</b> If color is set as a string (e.g. 'red .5') it has a priority over opt_opacity, which
 * means: <b>fill</b> set like this <b>rect.fill('red 0.3', 0.7)</b> will have 0.3 opacity.
 * @shortDescription Fill as a string or an object.
 * @example <t>simple-h100</t>
 * var bg = new anychart.elements.Background();
 * // Set fill
 *   bg.fill('red', 0.1);
 * bg.container(stage)
 *   .bounds( new anychart.math.Rect(10, 10, stage.width()-20, stage.height()-20) )
 *   .draw();
 * @param {string} color Fill as a string.
 * @param {number=} opt_opacity Fill opacity.
 * @return {!anychart.elements.Background} {@link anychart.elements.Background} instance for method chaining.
 */
anychart.elements.Background.prototype.fill;

/**
 * Linear gradient fill.<br/>
 * There are three modes:
 * <ul>
 *  <li>ObjectBoundingBox preserving an angle</li>
 *  <li>ObjectBoundingBox no angle preservation</li>
 *  <li>UserSpaceOnUse</li>
 * </ul>
 * <h4>Modes:</h4>
 * <p><b>ObjectBoundingBox preserving an angle</b><br/>
 * If boolean is passed it says how gradient behaves, specificaly
 * how gradient line angle behaves. If true - it is ObjectBoundingBox
 * with angle preservation. If angle is preserved, in any shape angle looks as one expects it to see.<br/>
 * <b>Note:</b> By default gradient vector for any shape, which sides are not in 1:1 proportions, will not
 * look as expected, because browser transforms this angle.</p>
 * <p><b>ObjectBoundingBox no angle preservation</b><br/>
 * If false is passed - that's ObjectBoundingBox no angle preservation. In this case default
 * behaviour comes up - gradient vector is calculated for a shape with 1:1 side proportions.</p>
 * <p><b>UserSpaceOnUse</b><br/>
 * If anychart.graphics.math.Rect is passed - that'sUserSpaceOnUse mode.
 * In this mode gradient gets its own size and coordinates. Shapes with such gradient will be colored
 * only in those parts, which are covered by this custom gradient. Read more about this mode at
 * <a href='https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementGradientUnitsAttribute'>
 * gradientUnits</a>. Angle is always preserved in this mode.</p>
 * @shortDescription Linear gradient fill.
 * @illustration <t>simple</t>
 * stage.text(0*stage.width()/6+3, 0, 'a');
 * new anychart.elements.Background()
 *   .fill(['0.2 black', 'white'], 45)
 *   .bounds( new anychart.math.Rect(0*stage.width()/6+3, 13, stage.width()/7-6, stage.height()-20) )
 *   .container(stage).draw();
 * stage.text(1*stage.width()/6-5, 0, 'b');
 * new anychart.elements.Background()
 *   .fill(['0.2 black', 'white'], 45, true)
 *   .bounds( new anychart.math.Rect(1*stage.width()/6-5, 13, stage.width()/7-6, stage.height()-20) )
 *   .container(stage).draw();
 * stage.text(2*stage.width()/6+3, 0, 'c');
 * new anychart.elements.Background()
 *   .fill(['red', 'blue'], 45, {left: 10, top: 20, width: 100, height: 100})
 *   .bounds( new anychart.math.Rect(2*stage.width()/6+3, 13, stage.width()/7-6, stage.height()-20) )
 *   .container(stage).draw();
 * new anychart.elements.Background()
 *   .fill(['red', 'blue'], 45, new anychart.math.Rect(10, 20, 100, 100))
 *   .bounds( new anychart.math.Rect(3*stage.width()/6-5, 13, stage.width()/7-6, stage.height()-20) )
 *   .container(stage).draw();
 * stage.text(4*stage.width()/6+3, 0, 'd');
 * new anychart.elements.Background()
 *   .fill(['red 0.1', 'orange', 'red 0.1'])
 *   .bounds( new anychart.math.Rect(4*stage.width()/6+3, 13, stage.width()/7-6, stage.height()-20) )
 *   .container(stage).draw();
 * new anychart.elements.Background()
 *   .fill(['red', {offset: 0.3, color: 'orange'}, 'red 0.1'])
 *   .bounds( new anychart.math.Rect(5*stage.width()/6-5, 13, stage.width()/7-6, stage.height()-20) )
 *   .container(stage).draw();
 * @illustrationDesc
 *  a) ObjectBoundingBox no angle preservation.<br/>
 *  b) ObjectBoundingBox preserving an angle.<br/>
 *  c) UserSpaceOnUse.<br/>
 *  d) Three step gradients.<br/>
 * @param {!Array.<(anychart.graphics.vector.GradientKey|string)>} keys Gradient keys.
 * @param {number=} opt_angle Gradient angle.
 * @param {(boolean|!anychart.graphics.vector.Rect|!{left:number,top:number,width:number,height:number})=} opt_mode Gradient mode.
 * @param {number=} opt_opacity Gradient opacity.
 * @return {!anychart.elements.Background} {@link anychart.elements.Background} instance for method chaining.
 */
anychart.elements.Background.prototype.fill;

/**
 * Radial gradient fill.
 * @example <t>simple-h100</t>
 * var bg = new anychart.elements.Background();
 * // set fill
 *   bg.fill(['black', 'white'], .5, .5, null, .9, 0.3, 0.81)
 * bg.container(stage)
 *   .bounds( new anychart.math.Rect(10, 10, 90, 90) )
 *   .draw();
 * @param {!Array.<(anychart.graphics.vector.GradientKey|string)>} keys Color-stop gradient keys.
 * @param {number} cx X ratio of center radial gradient.
 * @param {number} cy Y ratio of center radial gradient.
 * @param {anychart.graphics.math.Rect=} opt_mode If defined then userSpaceOnUse mode, else objectBoundingBox.
 * @param {number=} opt_opacity Opacity of the gradient.
 * @param {number=} opt_fx X ratio of focal point.
 * @param {number=} opt_fy Y ratio of focal point.
 * @return {!anychart.elements.Background} {@link anychart.elements.Background} instance for method chaining.
 */
anychart.elements.Background.prototype.fill;

/**
 * Returns current stroke.
 * @return {anychart.graphics.vector.Stroke} Returns current stroke.
 */
anychart.elements.Background.prototype.stroke;

/**
 * Sets stroke settings using one parameter.<br/>
 * Accepts:
 * <ul>
 * <li>String formatted as '[thickness ]color[ opacity]':
 * <ol>
 * <li><b>'color'</b> - {@link https://www.w3schools.com/html/html_colors.asp}.</li>
 * <li><b>'thickness color'</b> - like a css border, e.g. '3 red' or '3px red'</li>
 * <li><b>'color opacity'</b> - as a fill string, e.g. '#fff 0.5'</li>
 * <li><b>'thickness color opacity'</b> - as a complex string, e.g. '3px #00ff00 0.5'</li>
 * </ol>
 * </li>
 * <li>{@link anychart.graphics.vector.Stroke} object</li>
 * <li>{@link anychart.graphics.vector.GradientKey} keys array</li>
 * <li><b>null</b> resets current stroke settings</li>
 * </ul>
 * <b>Note:</b> String parts order is significant and '3px red' is not the same as 'red 3px'.
 * @shortDescription Sets stroke settings using one parameter.
 * @example <c>String</c><t>simple</t>
 * new anychart.elements.Background()
 *   .bounds( new anychart.math.Rect(stage.width()/2-8, 5, 16, stage.height()-10) )
 *   .fill('none').container(stage).draw();
 * new anychart.elements.Background()
 *   .stroke('red')
 *   .bounds( new anychart.math.Rect(30, 0.4*stage.height()/4, stage.width()-60, stage.height()/4 - 30) )
 *   .fill('none').container(stage).draw();
 * new anychart.elements.Background()
 *   .stroke('4px ORANGE')
 *   .bounds( new anychart.math.Rect(30, 1.4*stage.height()/4, stage.width()-60, stage.height()/4 - 30) )
 *   .fill('none').container(stage).draw();
 * new anychart.elements.Background()
 *   .stroke('#0f0 0.7')
 *   .bounds( new anychart.math.Rect(30, 2.4*stage.height()/4, stage.width()-60, stage.height()/4 - 30) )
 *   .fill('none').container(stage).draw();
 * new anychart.elements.Background()
 *   .stroke('4 #0000FF 0.3')
 *   .bounds( new anychart.math.Rect(30, 3.4*stage.height()/4, stage.width()-60, stage.height()/4 - 35) )
 *   .fill('none').container(stage).draw();
 * @example <c>Object or array</c><t>simple</t>
 * new anychart.elements.Background()
 *   .stroke({color: '#f00', thickness: 2, opacity: 0.9})
 *   .bounds( new anychart.math.Rect(30, 0.3*stage.height()/2, stage.width()-60, stage.height()/2 - 50) )
 *   .fill('none').container(stage).draw();
 * new anychart.elements.Background()
 *   .stroke(['red', 'green', 'blue'])
 *   .bounds( new anychart.math.Rect(30, 1.3*stage.height()/2, stage.width()-60, stage.height()/2 - 50) )
 *   .fill('none').container(stage).draw();
 * @param {(anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill|string|null)} value ['#000'] Fill formatted as '[thickness ]color[ opacity]'.
 * @return {anychart.elements.Background} {@link anychart.elements.Background} class for method chaining.
 */
anychart.elements.Background.prototype.stroke;

/**
 * Sets stroke settings.<br/>
 * <b>Note:</b> When stroke properties are set both by complex stroke object properties and by stroke() method params,
 * object properties have priority. E.g. setting <b>shape.stroke('10 red', 5);</b> (or <b>shape.stroke({color: 'red',
 * thickness: 10}, 5);</b> will result in a red stroke with thickness 10px.
 * @shortDescription Sets stroke settings.
 * @example <t>simple</t>
 * new anychart.elements.Background()
 *   .stroke('red .5', 4)
 *   .bounds( new anychart.math.Rect(30, 0.4*stage.height()/4, stage.width()-60, stage.height()/4 - 30) )
 *   .fill('none').container(stage).draw();
 * new anychart.elements.Background()
 *   .stroke('5 orange .5', 1)
 *   .bounds( new anychart.math.Rect(30, 1.2*stage.height()/4, stage.width()-60, 0.6*stage.height()/4) )
 *   .fill('none').container(stage).draw();
 * new anychart.elements.Background()
 *   .stroke(['red', 'green', 'blue'], 5, '5 2')
 *   .bounds( new anychart.math.Rect(30, 2.2*stage.height()/4, stage.width()-60, 0.6*stage.height()/4) )
 *   .fill('none').container(stage).draw();
 * new anychart.elements.Background()
 *   .stroke({color: '#00B'}, 10, '', anychart.graphics.vector.StrokeLineJoin.ROUND, anychart.graphics.vector.StrokeLineCap.SQUARE)
 *   .bounds( new anychart.math.Rect(30, 3.2*stage.height()/4, stage.width()-60, 0.6*stage.height()/4 -5) )
 *   .fill('none').container(stage).draw();
 * @param {(anychart.graphics.vector.Stroke|anychart.graphics.vector.ColoredFill|string)} value Fill settings.
 * @param {number=} opt_thickness Line thickness. Defaults to 1 of not set.
 * @param {string=} opt_dashpattern Controls the pattern of dashes and gaps used to stroke paths. Dash array contains a
 * list of white space separated lengths and percentages that specify the lengths of alternating dashes and gaps. If an
 * odd number of values is provided, then the list of values is repeated to yield an even number of values. Thus, stroke
 * dashpattern: '5 3 2' is equivalent to dashpattern: '5 3 2 5 3 2'.
 * @param {anychart.graphics.vector.StrokeLineJoin=} opt_lineJoin Line join style.
 * @param {anychart.graphics.vector.StrokeLineCap=} opt_lineCap Line cap style.
 * @return {anychart.elements.Background} {@link anychart.elements.Background} instance for method chaining.
 */
anychart.elements.Background.prototype.stroke;

/**
 * Render background.
 * @return {!anychart.elements.Background} {@link anychart.elements.Background} instance for method chaining.
 */
anychart.elements.Background.prototype.draw;

/**
 * Constructor function.
 * @return {!anychart.elements.Background}
 */
anychart.elements.background;

