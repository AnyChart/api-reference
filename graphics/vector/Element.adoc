/**
 <b>Abstract</b> class for all vector elements, such as groups and primitives.
 Due to the fact that this class is a child of from goog.events.EventTarget
 all its childs can work with events.<br/>
 <b>Never call a constructor directly!</b>
 @name anychart.graphics.vector.Element
 @constructor
 */
anychart.graphics.vector.Element;

/**
 Gets element identifier. If it was not set, it will be generated and applied to the DOM.
 @return {string} Returns element identifier.
 */
anychart.graphics.vector.Element.prototype.id;

/**
 Sets element identifier.
 @param {string=} opt_value Custom identifier.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.id;

/**
 Stage object (to which the given element is bound).
 @return {anychart.graphics.vector.Stage} Stage object.
 */
anychart.graphics.vector.Element.prototype.getStage;

/**
 Returns DOM element if element is rendered.<br/>
 In case of Stage in Suspended state or unbound element â€“ null is returned.
 @return {Element} DOM element.
 */
anychart.graphics.vector.Element.prototype.domElement;

/**
 Returns the parent layer.
 @return {anychart.graphics.vector.Layer|anychart.graphics.vector.Stage} Instance of element current layer.
 */
anychart.graphics.vector.Element.prototype.parent;

/**
 Adds element to the given layer.
 @param {(anychart.graphics.vector.Layer|anychart.graphics.vector.Stage)=} opt_value Parent layer.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.parent;

/**
 Whether parent element is set.
 @return {boolean} Whether parent element is set.
 */
anychart.graphics.vector.Element.prototype.hasParent;

/**
 Current element removes itself from the parent layer.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.remove;

/**
 Getter for cursor type.
 @return {?anychart.graphics.vector.Cursor} Current cursor type.
 */
anychart.graphics.vector.Element.prototype.cursor;

/**
 Setter for cursor type.
 @param {anychart.graphics.vector.Cursor=} opt_value Cursor type.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.cursor;

/**
 Rotates a shape around the given rotation point.
 @illustration <t>stageOnly</t>
 stage.suspend();
 var layer1 = stage.layer();
 // border
 layer1.rect(0, 0, stage.width()/2, stage.height());
 // target
 layer1.triangleDown(stage.width()/4, stage.height()/2, stage.height()/3)
   .fill(['#444 0.2', '#888 0.2'], -90)
   .stroke('2 #222 0.2');
 layer1.triangleDown(stage.width()/4, stage.height()/2, stage.height()/3)
   .fill(['#00A', '#00F'], -90)
   .stroke('2 #007')
   .rotate(20);
 layer1.circle(0, 0, 7).fill('red');
 var layer2 = stage.layer();
 // border
 layer2.rect(0, 0, stage.width()/2, stage.height());
 // target
 layer2.triangleDown(stage.width()/4, stage.height()/2, stage.height()/3)
   .fill(['#444 0.2', '#888 0.2'], -90)
   .stroke('2 #222 0.2');
 layer2.triangleDown(stage.width()/4, stage.height()/2, stage.height()/3)
   .fill(['#00A', '#00F'], -90)
   .stroke('2 #007')
   .rotate(20, stage.width()/4, stage.height()/2);
 layer2.circle(stage.width()/4, stage.height()/2, 7).fill('red');
 layer2.translate(stage.width()/2,0);
 stage.resume();
 @illustrationDesc
 If rotation point is not set then rotation point is <b>(0, 0)</b>.<br/>
 Left illustration shows 20 degrees rotation with the default rotation point.<br/>
 <code>.rotate(20)</code><br/>
 Right illustrarion shows 20 degrees rotation with the given rotation point.<br/>
 <code>.rotate(20, x, y)</code><br/>
 Rotation points are marked with red, initial position of shapes is marked with gray.
 @param {number} degrees Rotation angle in degrees.
 @param {number=} opt_cx Rotation point X.
 @param {number=} opt_cy Rotation point Y.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.rotate;

/**
 Rotates a shape around the given anchor.
 @illustration <t>stageOnly</t>
 stage.suspend();
 var layer1 = stage.layer();
 // border
 layer1.rect(0, 0, stage.width() / 2, stage.height());
 // target
 var triangleGray1 = layer1.triangleDown(stage.width() / 4, stage.height() / 2, stage.height() / 3)
   .fill(['#444 0.2', '#888 0.2'], -90)
   .stroke('2 #222 0.2');
 // draw its bounds
 layer1.rect()
   .setBounds(triangleGray1.getBounds())
   .stroke('1 #888 .5');
 var triangleBlue1 = layer1.triangleDown(stage.width() / 4, stage.height() / 2, stage.height() / 3)
   .fill(['#00A', '#00F'], -90)
   .stroke('2 #007')
   .rotateByAnchor(90);
 // draw its bounds
 layer1.rect()
   .setBounds(triangleBlue1.getBounds())
   .stroke('1 #00F .5');
 var triangleBounds1 = triangleGray1.getBounds();
 layer1.circle(triangleBounds1.left + triangleBounds1.width/2, triangleBounds1.top + triangleBounds1.height/2, 7).fill('red');
 var layer2 = stage.layer();
 // border
 layer2.rect(0, 0, stage.width() / 2, stage.height());
 // target
 layer2.rect()
       .setBounds(
         layer2.triangleDown(stage.width() / 4, stage.height() / 2, stage.height() / 3)
             .fill(['#444 0.2', '#888 0.2'], -90)
             .stroke('2 #222 0.2')
             .getBounds())
       .stroke('1 #888 .5');
 layer2.rect()
       .setBounds(
          layer2.triangleDown(stage.width() / 4, stage.height() / 2, stage.height() / 3)
             .fill(['#00A', '#00F'], -90)
             .stroke('2 #007')
             .rotateByAnchor(90, anychart.graphics.vector.Anchor.CENTER_TOP)
             .getBounds())
       .stroke('1 #00F .5');
 layer2.circle(stage.width() / 4, stage.height() / 3, 7).fill('red');
 layer2.translate(stage.width() / 2, 0);
 stage.resume();
 @illustrationDesc
 If anchor is not set <b>anychart.graphics.vector.Anchor.CENTER</b> is the default.<br/>
 Left illustration shows 90 degrees rotation around the default anchor.<br/>
 <code>.rotateByAnchor(90)</code><br/>
 Right illustration shows 90 degrees rotation around the given anchor.<br/>
 <code>.rotateByAnchor(90, anychart.graphics.vector.Anchor.CENTER_TOP)</code><br/>
 Rotation points are marked with red, initial position of shapes is marked with gray.
 @param {number} degrees Rotation angle in degress.
 @param {(anychart.graphics.vector.Anchor|string)=} opt_anchor Rotation anchor.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.rotateByAnchor;

/**
 Rotates a shape around the given point.<br/>
 <b>Note:</b> See illustration at {@link anychart.graphics.vector.Element#rotate}, the only difference
 between {@link anychart.graphics.vector.Element#rotate} and this method is the fact
 that this method resets the current transformation, and {@link anychart.graphics.vector.Element#rotate} adds rotation
 to the existing transformation.
 @shortDescription Rotatates a shape around the given point.
 @param {number} degrees Rotation angle in degrees.
 @param {number=} opt_cx Rotation point X.
 @param {number=} opt_cy Rotation point Y.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.setRotation;

/**
 Rotates a shape around the given anchor.<br/>
 <b>Note:</b> See illustration at {@link anychart.graphics.vector.Element#rotateByAnchor}, the only difference
 between {@link anychart.graphics.vector.Element#rotateByAnchor} and this method is the fact
 that this method resets the current transformation, and  and {@link anychart.graphics.vector.Element#rotate} adds rotation
 to the existing transformation.
 @shortDescription  Rotates a shape around the given anchor.
 @param {number} degrees Rotation angle in degrees.
 @param {(anychart.graphics.vector.Anchor|string)=} opt_anchor Rotation anchor.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.setRotationByAnchor;

/**
 Moves a shape taking an account the current transformation.
 Movement happens in a shape coordinate system (not the coordinate system of the parent).
 @illustration <t>stageOnly</t>
 stage.suspend();
 stage.triangleDown(stage.width() / 4, stage.height() / 3, stage.height() / 3)
    .fill(['#444 0.2', '#888 0.2'], -90)
    .stroke('2 #222 0.2');
 stage.triangleDown(stage.width() / 4, stage.height() / 3, stage.height() / 3)
    .fill(['#444 0.2', '#888 0.2'], -90)
    .stroke('2 #222 0.2')
    .translate(20, 10);
 stage.triangleDown(stage.width() / 4, stage.height() / 3, stage.height() / 3)
    .fill(['#444 0.2', '#888 0.2'], -90)
    .stroke('2 #222 0.2')
    .translate(20, 10)
    .translate(20, 10);
 stage.triangleDown(stage.width() / 4, stage.height() / 3, stage.height() / 3)
    .fill(['#00A', '#00F'], -90)
    .stroke('2 #007')
    .translate(20, 10)
    .translate(20, 10)
    .translate(20, 10);
 stage.resume();
 @illustrationDesc
 Illustration shows a shape movement when <code>.translate(20, 10)</code> is invoked several times.
 @param {number} tx X movement amount.
 @param {number} ty Y movement amount.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.translate;

/**
 Sets top left corner of a shape (transformation taken into account) in the coordinate system of the parent.<br/>
 <b>Note:</b> See illustration at {@link anychart.graphics.vector.Element#translate}, the only difference
 between {@link anychart.graphics.vector.Element#translate} and this method is the fact that
 that this method resets the current transformation, and  and {@link anychart.graphics.vector.Element#translate} adds movement
 to the existing transformation.
 @shortDescription Sets top left corner of a shape (transformation taken into account) in the coordinate system of the parent.
 @param {number} x X coordinate.
 @param {number} y Y coordinate.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.setPosition;

/**
 Scales a shape. Scaling center is set in the coordinate system of the parent.
 @illustration <t>stageOnly</t>
 stage.suspend();
 var layer1 = stage.layer();
 // border
 layer1.rect(0, 0, stage.width() / 2, stage.height());
 // target
 var triangleGray1 = layer1.triangleDown(stage.width() / 4, stage.height() / 2, stage.height() / 3)
   .fill(['#444 0.2', '#888 0.2'], -90)
   .stroke('2 #222 0.2');
 // draw its bounds
 layer1.rect()
   .setBounds(triangleGray1.getBounds())
   .stroke('1 #888 .5');
 var triangleBlue1 = layer1.triangleDown(stage.width() / 4, stage.height() / 2, stage.height() / 3)
   .fill(['#00A', '#00F'], -90)
   .stroke('2 #007')
   .scale(0.5, 0.5);
 // draw its bounds
 layer1.rect()
   .setBounds(triangleBlue1.getBounds())
   .stroke('1 #00F .5');
 layer1.circle(0, 0, 7).fill('red');
 var layer2 = stage.layer();
 // border
 layer2.rect(0, 0, stage.width() / 2, stage.height());
 // target
 layer2.rect()
     .setBounds(
       layer2.triangleDown(stage.width() / 4, stage.height() / 2, stage.height() / 3)
           .fill(['#444 0.2', '#888 0.2'], -90)
           .stroke('2 #222 0.2')
           .getBounds())
         .stroke('1 #888 .5');
 layer2.rect()
     .setBounds(
       layer2.triangleDown(stage.width() / 4, stage.height() / 2, stage.height() / 3)
           .fill(['#00A', '#00F'], -90)
           .stroke('2 #007')
           .scale(0.5, 0.5, stage.width() / 4, stage.height() / 2)
           .getBounds())
         .stroke('1 #00F .5');
 layer2.circle(stage.width() / 4, stage.height() / 2, 7).fill('red');
 layer2.translate(stage.width() / 2, 0);
 stage.resume();
 @illustrationDesc
 If the scaling center is not set it defaults to <b>(0, 0)</b>.<br/>
 Left illustration shows default point scaling.<br/>
 <code>.scale(0.5, 0.5,)</code><br/>
 Right illustration shows scaling with the scaling center set.<br/>
 <code>.scale(0.5, 0.5, x, y)</code><br/>
 Scaling center is marked with red, initial state is marked with gray.
 @param {number} sx X scaling factor.
 @param {number} sy Y scaling factor.
 @param {number=} opt_cx Scaling point X.
 @param {number=} opt_cy Scaling point Y.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.scale;

/**
 Scales a shape. Scaling center is set as an anchor.
 @illustration <t>stageOnly</t>
 stage.suspend();
 var layer1 = stage.layer();
 // border
 layer1.rect(0, 0, stage.width() / 2, stage.height());
 // target
 var triangleGray1 = layer1.triangleDown(stage.width() / 4, stage.height() / 2, stage.height() / 3)
   .fill(['#444 0.2', '#888 0.2'], -90)
   .stroke('2 #222 0.2');
 // draw its bounds
 layer1.rect()
   .setBounds(triangleGray1.getBounds())
   .stroke('1 #888 .5');
 var triangleBlue1 = layer1.triangleDown(stage.width() / 4, stage.height() / 2, stage.height() / 3)
   .fill(['#00A', '#00F'], -90)
   .stroke('2 #007')
   .scaleByAnchor(0.5, 0.5);
 // draw its bounds
 layer1.rect()
   .setBounds(triangleBlue1.getBounds())
   .stroke('1 #00F .5');
 var triangleBounds1 = triangleGray1.getBounds();
 layer1.circle(triangleBounds1.left + triangleBounds1.width / 2, triangleBounds1.top + triangleBounds1.height / 2, 7).fill('red');
 var layer2 = stage.layer();
 // border
 layer2.rect(0, 0, stage.width() / 2, stage.height());
 // target
 var triangleGray2 = layer2.triangleDown(stage.width() / 4, stage.height() / 2, stage.height() / 3)
   .fill(['#444 0.2', '#888 0.2'], -90)
   .stroke('2 #222 0.2');
 layer2.rect()
   .setBounds(triangleGray2.getBounds())
   .stroke('1 #888 .5');
 layer2.rect()
   .setBounds(
     layer2.triangleDown(stage.width() / 4, stage.height() / 2, stage.height() / 3)
       .fill(['#00A', '#00F'], -90)
       .stroke('2 #007')
       .scaleByAnchor(0.5, 0.5, anychart.graphics.vector.Anchor.RIGHT_TOP)
       .getBounds())
   .stroke('1 #00F .5');
 var triangleBounds2 = triangleGray2.getBounds();
 layer2.circle(triangleBounds2.left + triangleBounds2.width, triangleBounds2.top, 7).fill('red');
 layer2.translate(stage.width() / 2, 0);
 stage.resume();
 @illustrationDesc
 If anchor is not set it defaults to <b>anychart.graphics.vector.Anchor.CENTER</b>.<br/>
 Left illustration shows scaling with the defaut anchor.<br/>
 <code>.scaleByAnchor(0.5, 0.5)</code><br/>
 Right illustration shows scaling with the anchor set.<br/>
 <code>.scaleByAnchor(0.5, 0.5, anychart.graphics.vector.Anchor.RIGHT_TOP)</code><br/>
 Scaling center is marked with red, initial state is marked with gray.
 @param {number} sx X scaling factor.
 @param {number} sy Y scaling factor.
 @param {(anychart.graphics.vector.Anchor|string)=} opt_anchor Scaling anchor point.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.scaleByAnchor;

/**
 Combines the current transformation with the given transformation matrix.
 Combination is done via matrix multiplication (multiplication to the right).
 @illustration <t>stageOnly</t>
 stage.suspend();
 stage.triangleDown(stage.width() / 4, stage.height() / 3, stage.height() / 3)
   .fill(['#444 0.2', '#888 0.2'], -90)
   .stroke('2 #222 0.2');
 stage.triangleDown(stage.width() / 4, stage.height() / 3, stage.height() / 3)
   .fill(['#444 0.2', '#888 0.2'], -90)
   .stroke('2 #222 0.2')
   .appendTransformationMatrix(0, 0.5, 1, 0, 0, 0);
 stage.triangleDown(stage.width() / 4, stage.height() / 3, stage.height() / 3)
   .fill(['#00A', '#00F'], -90)
   .stroke('2 #007')
   .appendTransformationMatrix(0, 0.5, 1, 0, 0, 0)
   .appendTransformationMatrix(0, 0.5, 1, 0, 0, 0);
 stage.resume();
 @illustrationDesc
 Illustration shows a shape transformation with the several calls of
 <code>.appendTransformationMatrix(0, 0.5, 1, 0, 0, 0)</code>
 @param {number} m00 Scale X.
 @param {number} m10 Shear Y.
 @param {number} m01 Shear X.
 @param {number} m11 Scale Y.
 @param {number} m02 Translate X.
 @param {number} m12 Translate Y.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.appendTransformationMatrix;

/**
 Sets transformation matrix.<br/>
 <b>Note:</b> See illustration at {@link anychart.graphics.vector.Element#appendTransformationMatrix},
 the difference between {@link anychart.graphics.vector.Element#appendTransformationMatrix} and this method
 is that {@link anychart.graphics.vector.Element#appendTransformationMatrix} combined transformation with
 the current, and this method resets the current.
 @shortDescription Sets transformation matrix.
 @param {number} m00 Scale X.
 @param {number} m10 Shear Y.
 @param {number} m01 Shear X.
 @param {number} m11 Scale Y.
 @param {number} m02 Translate X.
 @param {number} m12 Translate Y.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.setTransformationMatrix;

/**
 Returns the current rotation angle in degrees.
 @return {number} Rotation angle.
 */
anychart.graphics.vector.Element.prototype.getRotationAngle;

/**
 Returns the current transformation matrix as an array of six elements:<br>
 [<br>
 &nbsp;&nbsp;{number} m00 Scale X.<br>
 &nbsp;&nbsp;{number} m10 Shear Y.<br>
 &nbsp;&nbsp;{number} m01 Shear X.<br>
 &nbsp;&nbsp;{number} m11 Scale Y.<br>
 &nbsp;&nbsp;{number} m02 Translate X.<br>
 &nbsp;&nbsp;{number} m12 Translate Y.<br>
 ]
 @shortDescription Returns the current transformation matrix.
 @return {Array.<number>} Transformation matrix array.
 */
anychart.graphics.vector.Element.prototype.getTransformationMatrix;

/**
 * Specifies under what circumstances a given graphics element can be a target element for a pointer event.
 * @param {boolean=} opt_value Pointer events property value.
 * @return {anychart.graphics.vector.Element|boolean} If opt_value defined then returns Element object for chaining else
 * returns property value.
 */
anychart.graphics.vector.Element.prototype.disablePointerEvents;

/**
 * Adds an event listener. A listener can only be added once to an
 * object and if it is added again the key for the listener is
 * returned. Note that if the existing listener is a one-off listener
 * (registered via listenOnce), it will no longer be a one-off
 * listener after a call to listen().
 *
 * @param {string} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {{key: number}} Unique key for the listener.
 * @template SCOPE,EVENTOBJ
 */
anychart.graphics.vector.Element.prototype.listen;

/**
 * Adds an event listener that is removed automatically after the
 * listener fired once.
 *
 * If an existing listener already exists, listenOnce will do
 * nothing. In particular, if the listener was previously registered
 * via listen(), listenOnce() will not turn the listener into a
 * one-off listener. Similarly, if there is already an existing
 * one-off listener, listenOnce does not modify the listeners (it is
 * still a once listener).
 *
 * @param {string} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {{key: number}} Unique key for the listener.
 * @template SCOPE,EVENTOBJ
 */
anychart.graphics.vector.Element.prototype.listenOnce;

/**
 * Removes an event listener which was added with listen() or listenOnce().
 *
 * @param {string} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call
 *     the listener.
 * @return {boolean} Whether any listener was removed.
 * @template SCOPE,EVENTOBJ
 */
anychart.graphics.vector.Element.prototype.unlisten;

/**
 * Removes an event listener which was added with listen() by the key
 * returned by listen().
 *
 * @param {{key: number}} key The key returned by
 *     listen() or listenOnce().
 * @return {boolean} Whether any listener was removed.
 */
anychart.graphics.vector.Element.prototype.unlistenByKey;

/**
 * Removes all listeners from this listenable. If type is specified,
 * it will only remove listeners of the particular type. otherwise all
 * registered listeners will be removed.
 *
 * @param {string=} opt_type Type of event to remove, default is to
 *     remove all types.
 * @return {number} Number of listeners removed.
 */
anychart.graphics.vector.Element.prototype.removeAllListeners;

/**
 * Gets and sets element's zIndex.
 * @param {number=} opt_value Z index to set.
 * @return {number|anychart.graphics.vector.Element} Z index or itself for chaining.
 */
anychart.graphics.vector.Element.prototype.zIndex;

/**
 Gets/sets the current visibility flag.
 @return {boolean} Returns the current visibility flag.
 */
anychart.graphics.vector.Element.prototype.visible;

/**
 Hides or shows an element.
 @example anychart.graphics.vector.Element.visible
 @param {boolean=} opt_isVisible Visibility flag.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.visible;

/**
 Gets/sets clipping rectangle.
 @return {anychart.graphics.math.Rect} An instance of class for method chaining.
 */
anychart.graphics.vector.Element.prototype.clip;

/**
 Sets clipping rectangle.
 Affects display only after render() method call.<br/>
 <b>Attention!</b> In SVG clip will transform according to transformation, and in VML
 clip will be surrounding.
 @shortDescription Sets clipping rectangle.
 @illustration <t>stageOnly</t>
 // colors
 var gray = '1 gray 0.3';
 var blue = '1 blue 0.9';
 //// Image #1
 // Gray star
 stage.star5(40, 55, 35).stroke(gray);
 // Clipping rectangle
 var rectToClip = new anychart.graphics.math.Rect(5, 20, 45, 45);
 // Star clipping
 stage.star5(40, 55, 35).clip(rectToClip);
 // Clip frame (blue)
 stage.rect().setBounds(rectToClip).fill('none').stroke(blue);
 // Label
 stage.text(10, 110, 'without');
 stage.text(10, 120, 'transformation');
 stage.text(10, 90, 'SVG/VML');
 //// Image #2
 // Gray star
 stage.star5(160, 55, 35).stroke(gray).rotateByAnchor(45, anychart.graphics.vector.Anchor.CENTER)
 // Star clipping
 stage.path()
 .moveTo(138, 48.5)
 .lineTo(142, 45.5)
 .lineTo(142, 23)
 .lineTo(161, 37)
 .lineTo(183, 29)
 .lineTo(175, 52);
 // Cliiping frame (blue)
 stage.rect(125, 20, 45, 45).fill('none').stroke(blue)
 .rotateByAnchor(45, anychart.graphics.vector.Anchor.CENTER)
 .translate(4, -12);
 // Label
 stage.text(180, 110, 'with');
 stage.text(180, 120, 'transformation');
 stage.text(160, 90, 'SVG');
 //// Image #3
 // Gray star
 stage.star5(240, 55, 35).stroke(gray).rotateByAnchor(45, anychart.graphics.vector.Anchor.CENTER);
 // Star clipping
 stage.path()
 .moveTo(206.5, 57)
 .lineTo(218, 48.5)
 .lineTo(222, 45.5)
 .lineTo(222, 23)
 .lineTo(241, 37)
 .lineTo(263, 29)
 .lineTo(255, 52)
 .lineTo(268, 68);
 stage.path()
 .moveTo(206.5, 60)
 .lineTo(225, 66)
 .lineTo(226, 68);
 // Clipping frame (gray)
 var rect = stage.rect(205, 20, 45, 45).fill('none').stroke(gray)
 .rotateByAnchor(45, anychart.graphics.vector.Anchor.CENTER)
 .translate(4, -12);
 // Clipping frame (blue)
 stage.rect().setBounds(rect.getBounds()).fill('none').stroke(blue);
 // Label
 stage.text(230, 90, 'VML');
 @param {(anychart.graphics.math.Rect|string)=} opt_value Clipping rectangle.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.clip;

/**
 Returns X in the coordinate system of the parent.
 @return {number} X in the coordinate system of the parent.
 */
anychart.graphics.vector.Element.prototype.getX;

/**
 Returns Y in the coordinate system of the parent.
 @return {number} Y in the coordinate system of the parent.
 */
anychart.graphics.vector.Element.prototype.getY;

/**
 Returns (X,Y) in the coordinate system of the parent.
 @return {!anychart.graphics.math.Coordinate} (X,Y) in the coordinate system of the parent.
 */
anychart.graphics.vector.Element.prototype.getCoordinate;

/**
 Returns  width.
 @return {number} Width.
 */
anychart.graphics.vector.Element.prototype.getWidth;

/**
 Returns height.
 @return {number} Height.
 */
anychart.graphics.vector.Element.prototype.getHeight;

/**
 Returns size.
 @return {!anychart.graphics.math.Size} Size.
 */
anychart.graphics.vector.Element.prototype.getSize;

/**
 Returns bounds.
 @return {!anychart.graphics.math.Rect} Bounds.
 */
anychart.graphics.vector.Element.prototype.getBounds;

/**
 Returns an absolute X (root element coordinate system).
 @illustration <t>stageOnly</t>
   stage.rect(1, 1, stage.width()-2, stage.height()-2)
       .stroke('1 green');
   stage.text(120, 1, 'root element').color('green');
   var layer = stage.layer();
   layer.rect(1, 1, stage.width()-2, stage.height()-2)
       .fill('blue 0.01')
       .stroke('1 blue');
   layer.text(120, 1, 'layer with transformation').color('blue');
   layer.translate(40, 20);
   layer.rect(10, 10, 100, 40).fill("#9E9E9E")
       .rotate(10)
       .translate(50, 30);
   layer.path()
       .stroke('2 brown')
       .moveTo(0, 90)
       .lineTo(45, 90);
   layer.text(10, 90, 'getX()')
       .color('brown');
   stage.path()
       .stroke('1 gray')
       .moveTo(0, 109)
       .lineTo(85, 109);
   stage.text(7, 90, 'getAbsoluteX()')
       .color('black');
   stage.circle(85, 109, 2).fill('#000')
 @return {number} Absolute X.
 */
anychart.graphics.vector.Element.prototype.getAbsoluteX;

/**
 Returns an absolute Y (root element coordinate system).
 @illustration <t>stageOnly</t>
 stage.rect(1, 1, stage.width()-2, stage.height()-2)
     .stroke('1 green');
 stage.text(120, 1, 'root element').color('green');
 var layer = stage.layer();
 layer.rect(1, 1, stage.width()-2, stage.height()-2)
     .fill('blue 0.01')
     .stroke('1 blue');
 layer.text(120, 1, 'layer with transformation').color('blue');
 layer.translate(40, 20);
 layer.rect(10, 10, 100, 40).fill("#9E9E9E")
     .rotate(10)
     .translate(50, 30);
 layer.path()
     .stroke('2 brown')
     .moveTo(0, 90)
     .lineTo(45, 90);
 layer.text(10, 40, 'getY()')
     .color('brown');
 stage.path()
     .stroke('1 gray')
     .moveTo(85, 0)
     .lineTo(85, 109);
 stage.text(7, 0, 'getAbsoluteY()')
     .color('black');
 stage.circle(85, 109, 2).fill('#000')
 @return {number} Absolute Y.
 */
anychart.graphics.vector.Element.prototype.getAbsoluteY;

/**
 Returns absolute coordinates (root element coordinate system).<br/>
 See illustrations at {@link anychart.graphics.vector.Element#getAbsoluteX} and {@link anychart.graphics.vector.Element#getAbsoluteY}
 @return {!anychart.graphics.math.Coordinate} Absolute coordinates.
 */
anychart.graphics.vector.Element.prototype.getAbsoluteCoordinate;

/**
 Returns width within root bounds.
 @illustration <t>stageOnly</t>
 stage.rect(1, 1, stage.width()-2, stage.height()-2)
     .stroke('1 green');
 stage.text(120, 1, 'root element').color('green');
 var layer = stage.layer();
 layer.rect(1, 1, stage.width()-2, stage.height()-2)
     .fill('blue 0.01')
     .stroke('1 blue');
 layer.text(120, 1, 'layer with transformation').color('blue');
 layer.translate(40, 20);
 layer.rect(10, 10, 100, 40).fill('gray .4')
     .rotate(10)
     .translate(50, 30)
     .stroke('2 brown');
 layer.text(160, 70, 'elements bounds')
     .color('brown');
 layer.rect(45, 49, 108, 59);
 stage.text(97, 50, 'absolute bounds')
     .color('black');
 @return {number} Width.
 */
anychart.graphics.vector.Element.prototype.getAbsoluteWidth;

/**
 Returns height within root bounds.
 @illustration <t>stageOnly</t>
 stage.rect(1, 1, stage.width()-2, stage.height()-2)
    .stroke('1 green');
 stage.text(120, 1, 'root element').color('green');
 var layer = stage.layer();
 layer.rect(1, 1, stage.width()-2, stage.height()-2)
    .fill('blue 0.01')
    .stroke('1 blue');
 layer.text(120, 1, 'layer with transformation').color('blue');
 layer.translate(40, 20);
 layer.rect(10, 10, 100, 40).fill('gray .4')
    .rotate(10)
    .translate(50, 30)
    .stroke('2 brown');
 layer.text(160, 70, 'elements bounds')
    .color('brown');
 layer.rect(45, 49, 108, 59);
 stage.text(97, 50, 'absolute bounds')
    .color('black');
 @return {number} Height.
 */
anychart.graphics.vector.Element.prototype.getAbsoluteHeight;

/**
 Returns size within root bounds.<br/>
 See illustrations at {@link anychart.graphics.vector.Element#getAbsoluteWidth} and {@link anychart.graphics.vector.Element#getAbsoluteHeight}
 @return {!anychart.graphics.math.Size} Size.
 */
anychart.graphics.vector.Element.prototype.getAbsoluteSize;

/**
 Gets element bounds in absolute coordinates (root element coordinate system).
 @illustration <t>stageOnly</t>
 stage.rect(1, 1, stage.width()-2, stage.height()-2)
     .stroke('1 green');
 stage.text(120, 1, 'root element').color('green');
 var layer = stage.layer();
 layer.rect(1, 1, stage.width()-2, stage.height()-2)
     .fill('blue 0.01')
     .stroke('1 blue');
 layer.text(120, 1, 'layer with transformation').color('blue');
 layer.translate(40, 20);
 layer.rect(10, 10, 100, 40).fill('gray .4')
     .rotate(10)
     .translate(50, 30)
     .stroke('2 brown');
 layer.text(160, 70, 'elements bounds')
     .color('brown');
 layer.rect(45, 49, 108, 59);
 stage.text(97, 50, 'absolute bounds')
     .color('black');
 @return {!anychart.graphics.math.Rect} Absolute element bounds.
 */
anychart.graphics.vector.Element.prototype.getAbsoluteBounds;

/**
 Returns current state flag.
 @return {boolean|anychart.graphics.math.Rect} .
 */
anychart.graphics.vector.Element.prototype.drag;

/**
 Turns off/on dragging (moving) of an element.<br/>
 Sets mode (true - on, false - off) or dragging area for an element,
 dragging is always on within an area.
 @shortDescription Turns off/on dragging (moving) of an element.
 @example anychart.graphics.vector.Element.drag
 @param {(boolean|anychart.graphics.math.Rect)=} opt_value Flag or a dragging area.
 @return {anychart.graphics.vector.Element} Self instance for method chaining.
 */
anychart.graphics.vector.Element.prototype.drag;

/**
 Disposes element completelt. Removes it from the parent layer, sets links to null,
 removes it from DOM.
 */
anychart.graphics.vector.Element.prototype.dispose = function(){};

